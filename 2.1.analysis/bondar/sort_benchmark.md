# Бенчмарк Quicksort (Первый отчет)

В этом отчете описывается процесс и результаты бенчмаркинга алгоритма quicksort, который был выполнен во время зимней школы YADRO 2025 по архитектуре RISC-V.

## Цель

Целями данной части работы были:

1. Оценка производительности алгоритма быстрой сортировки на платформе RISC-V и сравнение 2 тестируемых плат.
2. Получение практического опыта работы с инструментами анализа производительности:
   - Изучение инструментов performance профилирования (`perf`, `gprof`)
   - Развитие навыков выявления узких мест производительности
3. Получение опыта чтения и анализа ассемблера RISC V.

## Методология

### Алгоритм и обеспечение консистентности данных

Был реализован стандартный алгоритм быстрой сортировки на языке C.

Для оценки производительности алгоритма сортировка запускалась в цикле M раз. Это позволило увеличить долю времени выполнения, затрачиваемого непосредственно на сам алгоритм, и минимизировать влияние подготовительных операций.

Протестированны разные способы перетасовки сортируемого массива между циклами с целью получить единый способ проведения экспериментов с детерминированными и консистентными между прогонами данными.

При этом случайный массив для сортировки генерировался отдельным Python скриптом в виде header-файла `random_data.h` с `static` массивом. Данный header-файл подключается на этапе сборки и из него берутся данные для сортировки.

Исходный код: [rand_gen.py](/1.benchmarks/bondar/qsort_bench/rand_gen.py)

#### Версия с XOR и memcpy

В начале каждого цикла массив размера N копируется в рабочий буфер, после чего к каждому элементу применяется операция XOR с итерацией цикла, умноженной на большое простое число.

Этот метод является детерминированным, так как начальная точка (`base_array`) остается неизменной, и все операции XOR применяются к одинаковой последовательности чисел.

```C
    for (int cycle = 0; cycle < M; cycle++) {
        memcpy(buffer, base_array, N * sizeof(int));
        
        for (int i = 0; i < N; i++) {
            buffer[i] ^= (cycle * 0x5bd1e995);
        }
        
        quicksort(buffer, 0, N - 1);
    }
```

Результаты:

- Для N = 1000, M = 5000: ~17.7% branch misses.
- Для N = 10000, M = 500: ~19% branch misses.
- Доля времени, затрачиваемого на сортировку (измерено через `gprof`):
  - **91.2%** in `quicksort` (N = 1000, 5000 cycles)
  - **93.6%** in `quicksort` (N = 10000, 500 cycles)
  - **96.2%** in `quicksort` (N = 100, 50000 cycles)

Также был измерен процент промахов предсказаний ветвлений (branch misses) с помощью `perf stat` для исследования возможности "обмануть" предсказатель ветвлений (Branch Predictor) и получить с помощью перетасовки больший процент ошибок.

Как будет видно далее из результатов других реализаций, процент ошибок предсказаний слабо зависит от способа перетасовки массива.

Для достижения большего процента ошибок необходимо изменять внутреннюю логику алгоритма, например, механизм выбора опорного элемента (пивота).

Хорошая статья на эту тему: [Analysis of Branch Misses in Quicksort](https://www.wild-inter.net/publications/martinez-nebel-wild-2015).

Ввиду ограниченности времени тесты с альтернативными реализациями алгоритма не были проведены, к тому же это не являлось основной задачей исследования.

Исходный код: [sort_memcpy_xor.c](/1.benchmarks/bondar/qsort_bench/sort_memcpy_xor.c)

#### Версия scramble

Данная версия использует небольшую хэш-функцию для модификации элементов массива перед каждым прогоном сортировки.

```C
void scramble(int *arr, int n, int cycle) {
    for (int i = 0; i < n; i++) {
        unsigned int seed = (cycle * 0x5bd1e995) + (i * 0xdeadbeef);
        seed ^= (seed >> 16);

        arr[i] ^= seed; 
        arr[i] = (arr[i] << 3) | (arr[i] >> (32 - 3)); 
        arr[i] += (seed ^ 0x9e3779b9);
    }
}

...

    for (int cycle = 0; cycle < M; cycle++) {
        scramble(buffer, N, cycle);
        quicksort(buffer, 0, N - 1);
    }
```

Метод является полностью детерминированным, так как все преобразования зависят от начальных данных (`base_array`) и номера текущей итерации (`cycle`).

Результаты:

- Для N = 1000, M = 5000: ~17% branch misses.
- Для N = 10000, M = 500: ~18.65% branch misses.
- Доля времени, затрачиваемого на сортировку (измерено через `gprof`):
  - **84%** in `quicksort` (N = 1000, 5000 cycles)
  - **82%** in `quicksort` (N = 10000, 500 cycles)
  - **87.4%** in `quicksort` (N = 100, 50000 cycles)

Недостаток данного подхода — дополнительный оверхед из-за вычисления хэш-функции, что снижает долю времени, затрачиваемого непосредственно на выполнение алгоритма сортировки.

Процент промахов предсказаний ветвлений в этой версии сопоставим с другими методами перетасовки массива. Это подтверждает гипотезу, что способ перетасовки слабо влияет на работу Branch Predictor.

Исходный код: [sort_scramble.c](/1.benchmarks/bondar/qsort_bench/sort_scramble.c)

#### Версия memcpy with offset

Данная версия использует смещение (`offset`) для копирования подмассива из исходного массива данных. Смещение вычисляется детерминированным образом на основе номера текущей итерации цикла, что позволяет использовать разные части исходного массива на каждой итерации.

```C
    size_t max_offset = BASE_ARRAY_SIZE - N;
    const unsigned prime = 0x5bd1e995; 

    for (int cycle = 0; cycle < M; cycle++) {
        size_t offset = ((1ull * cycle * prime) % (max_offset + 1));
        memcpy(buffer, base_array + offset, N * sizeof(short));
        
        quicksort(buffer, 0, N - 1);
    }
```

Результаты:

- Для N = 1000, M = 5000: ~18.57% branch misses.
- Для N = 10000, M = 500: ~20% branch misses.
- Доля времени, затрачиваемого на сортировку (измерено через `gprof`):
  - **99%** in `quicksort` (N = 1000, 5000 cycles)
  - **99-100%** in `quicksort` (N = 10000, 500 cycles)
  - **99-100%** in `quicksort` (N = 100, 50000 cycles)

Основное преимущество данного подхода заключается в минимальном оверхеде, связанном с подготовкой данных. Поскольку `memcpy` является хорошо оптимизированной операцией, доля времени, затрачиваемого непосредственно на выполнение алгоритма сортировки, достигает ~99–100%.

Данный метод был выбран как **основной** для проведения бенчмарков.

Исходный код: [sort_memcpy_with_offset.c](/1.benchmarks/bondar/qsort_bench/sort_memcpy_with_offset.c)

## Инструменты

В ходе работы совершались следующие шаги с использованием сооответствующих инструментов:

1) **Компиляция кода**

    Код был скомпилирован с использованием RISC-V GCC toolchain. Для отключения оптимизаций компилятора использовался флаг `-O0`.

    ```bash
    gcc -O0 -o sort sort_memcpy_with_offset.c
    ```

2) **Дизассемблирование бинарных файлов**

    Для анализа ассемблерного кода бинарные файлы были дизассемблированы с помощью утилиты `objdump`. Это позволило изучить влияние компилятора на генерацию кода и выявить возможные оптимизации.

    ```bash
    objdump -d -S sort
    ```

3) **Профилирование с помощью gprof**

    Для исследования "горячих точек" кода (hotspots) использовался инструмент `gprof`. Была собрана информация о времени выполнения различных частей программы.

    Пример использования:

    ```bash
    gcc -pg -o sort sort_memcpy_with_offset.c
    ./sort
    gprof ./sort gmon.out > report.txt
    ```

4) **Автоматизация тестирования с помощью Bash-скрипта**

    Для упрощения проведения продолжительных тестов был написан автоматизирующий Bash-скрипт. Скрипт выполняет следующие задачи:
    - Запускает программу с разными значениями параметров (`N` и `M`) из файла `input.txt`.
    - Измеряет `VmRSS` память процесса через `/proc/$pid/status`.
    - Использует `perf stat` для сбора данных о производительности (количество промахов кэша, переключений контекста и времени выполнения).
    - Сохраняет результаты в лог-файл.

    Пример работы скрипта в реальном времени (для N = 1000):

    ```bash
    >>> For N = 1000:
        Memory usage (VmRSS): 1234 kB
        task-clock:        50.12 msec
        context-switches:  10
        cache-misses:      12345
    ```

    Исходный код: [bench.sh](/1.benchmarks/bondar/qsort_bench/bench.sh)

## Результаты исследования

### Первый результат

Первые прогоны бенчмарков сравнивали `memcpy + XOR` и `memcy with offset` реазизации.

Для каждой реализации были построены графики зависимости времени выполнения от размера массива (Time vs Array Size).

Также для обоих бенчмарков собирались данные об использовании `VmRSS` памяти, чтобы оценить момент, когда данные перестают помещаться в кэш процессора, и выявить возможные просадки производительности.

#### Версия quicksort memcpy и XOR

![quicksort memcy + XOR](./../../1.benchmarks/bondar/qsort_bench/pics/qsort_with_memcpy.png)

#### Версия quicksort memcpy with offset

![quicksort memcy with offset](./../../1.benchmarks/bondar/qsort_bench/pics/qsort_with_memcpy_offset.png)

#### Анализ

Как мы видим, плата LicheePi 4A оказалась немного быстрее чем Banana Pi BPI-F3, что ожидаемо учитывая немного более высокую тактовую частоту:

- LicheePi 4A: 1.85 GHz
- Banana Pi BPI-F3: 1.6 GHz

Также важно отметить, что бенчмарки проводились на неизолированных машинах без использования команды `taskset`. Несмотря на это, графики оказались достаточно гладкими, что можно считать удачным стечением обстоятельств. Как будет видно далее, внешний шум может значительно влиять на результаты тестов.

Мы также можем заметить, что на графиках не наблюдается резких скачков времени выполнения, которые могли бы указывать на выход за пределы кэша процессора. Это можно объяснить особенностью алгоритма `quicksort` — очень хорошей локальностью доступа к памяти.

### Важность внешних условий

Во второй день были получены сильно более шумные данные по причине менее благоприятных тестовых условий: на одной тестовой плате одновременно сидели через ssh соединение несколько пользователей. К тому же в програмном коде была допущена ошибка работы с памятью, что тоже могло повлиять на результаты.

![lichee vs banana noise](./../../1.benchmarks/bondar/qsort_bench/pics/qsort_2day_noisy.png)

![banana l1, l2 cache misses](./../../1.benchmarks/bondar/qsort_bench/pics/qsort_2day_noisy_banana_cache.png)

### Финальный результат

Для финальных прогонов бенчмарков был изменен подход к тестированию.

1. Изоляция тестовой среды:
    - Плата LicheePi 4A тестировалась на изолированной машине через монитор, подключенный по HDMI. Ethernet-кабель был физически отключен для исключения сетевых помех.
    - Плата Banana Pi BPI-F3 тестировалась через маленькую локальную сеть (подключение через роутер), изолированную от общей внешней сети.
2. Использование `taskset`:

    В Bash-скрипт было добавлено использование команды `taskset` для фиксации процессора, на котором выполнялись тесты. Это позволило минимизировать влияние планировщика задач.
3. Исправление ошибок:

    Были исправлены ошибки работы с памятью, допущенные в предыдущих версиях кода.
4. Измерение времени выполнения:

    Время работы программы теперь измерялось не через показатель `elapsed time`, а через метрику `task-clock`, которая отражает реальное время, проведенное на процессоре (CPU-time).

#### Banana vs Lichee

![Banana vs Lichee Final](./../../1.benchmarks/bondar/qsort_bench/pics/Banana-Lichee.svg)

#### Cache misses Lichee

![Caches Lichee](./../../1.benchmarks/bondar/qsort_bench/pics/Caches%20Lichee.svg)

#### Cache misses Banana

![Caches Banana](./../../1.benchmarks/bondar/qsort_bench/pics/Caches%20Banana.svg)

#### Анализ

Был получен прекрасный гладкий график, который снова показывает незначительное преимущество платы LicheePi 4A.

Также для обоих плат были тщательно измерены промахи кэша (cache misses). Как мы видим из полученных результатов:

- На плате Lichee промахи растут линейно с ростом массива, отсутствуют какие либо скачки. Что и ожидаемо в связи с уже упомянутой хорошей локальностью по памяти алгоритма `quicksort`.
- На плате Banana присутствует больше шумов и заметны сильные пики в районе 1M эл-тов, что является скорее погрешностью измерения, так как на 1М эл-тов L2 кэш уже был очень давно исчерпан.

    Вероятно это связано с тем, что измерения на плате Banana проводились через локальное подключение и хоть мы и имеем меньшее кол-во поступающих пакетов при таком подключении, все равно пакеты приходят и их необходимо обрабатывать при помощи прерываний.

### Измерение влияния внешнего шума

В предыдущих экспериментах были выявлены определённые расхождения в результатах, связанные с внешними факторами. Было принято решение подробнее исследовать влияние внешней среды.

Были проведены эксперименты:

- В обычных условиях с подключенной сетью и графической оболочкой
- В условиях отключения Ethernet кабеля
- В условиях отключения графической оболочки рабочего стола (Desktop Environment)

Измерялось кол-во переключений контекста и кол-во промахов кэша.

Также исследовано влияние `taskset` на кол-во переключений контекста.

#### taskset vs no taskset

![Taskset vs no Taskset](./../../1.benchmarks/bondar/qsort_bench/pics/taskset_vs_notaskset.svg)

![Taskset time](./../../1.benchmarks/bondar/qsort_bench/pics/taskset-time.svg)

Применение `taskset` не приводит к кардинальному снижению общего числа переключений контекста, однако заметно уменьшает флуктуации (шумы).

Время выполнения алгоритма `quicksort` остаётся практически неизменным, что свидетельствует о том, что привязка процесса к ядру не влияет на производительность самой сортировки, а лишь снижает разброс статистики.

#### No Ethernet & No DE

![Lichee no Ethernet cache misses](./../../1.benchmarks/bondar/qsort_bench/pics/Lichee-no-ethernet-misses.svg)

![Lichee no Ethernet context switches](./../../1.benchmarks/bondar/qsort_bench/pics/Lichee-no-ethernet-context.svg)

В данных экспериментах мы видим значительное влияние Ethernet подключения на кол-во промахов кэша (в ~2 раза) и переключений контекста(в ~5-8 раз).

Отключение графической оболочки не оказало сильного влияния.

Независимо от проводимых изменений в условиях тестирования, время работы алгоритма `quicksort` оставалось стабильным, что подтверждает его высокую локальность по памяти и отсутствие упора в кэш.

## Как воспроизвести бенчмарки

Для повторения экспериментов на вашей локальной системе:

```bash
make gen_data
make sort_mcpy / sort_mcpy_gprof / sort_xor / sort_xor_gprof
bash bench.sh M LOG_FILE
```

Исполнить python скрипт достаточно 1 раз и далее использовать полученный header во всех экспериментах.

Важно: Bash-скрипт производит запись в конец log-файла, если он уже существует.

## Заключение

Плата LicheePi 4A демонстрирует преимущество над Banana Pi BPI-F3 благодаря более высокой тактовой частоте.

В то же время, влияние внешних факторов, таких как сетевые подключения, существенно сказывается на точности измерений, поэтому минимизация этих помех является критически важной для корректного бенчмаркинга.

## Будущая работа

Основная дальнейшая работа лежит в направлении более глубокого изучения влияния внешних факторов на

- прерывания
- планировщик реального времени (необходимость для ядра 6.*)
- многопоточность
- nice
